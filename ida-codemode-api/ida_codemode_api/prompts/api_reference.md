## Function reference

All functions return either the success payload shown below or `{error: str}`.
Callers should check for the presence of the `error` key to detect failures.

| Function | Returns | Description |
|----------|---------|-------------|
| `help(api)` | `{documentation: str}` | Extensive documentation for a specific API callback. |
| `get_database_metadata()` | `{input_file_path: str, module: str, architecture: str, bitness: int, format: str, base_address: int, entry_point: int, minimum_ea: int, maximum_ea: int, input_file_size: int, input_file_md5: str, input_file_sha256: str}` | Database-wide metadata for the currently opened database. |
| `get_functions()` | `{functions: list[{address: int, name: str, size: int, signature: str, flags: {noreturn: bool, library: bool, thunk: bool}, comment: str, repeatable_comment: str}]}` | All discovered function descriptors. |
| `get_function_by_name(name)` | `{address: int, name: str, size: int, signature: str, flags: {noreturn: bool, library: bool, thunk: bool}, comment: str, repeatable_comment: str}` | Function descriptor resolved by exact symbol name. |
| `get_function_at(address)` | `{address: int, name: str, size: int, signature: str, flags: {noreturn: bool, library: bool, thunk: bool}, comment: str, repeatable_comment: str}` | Function descriptor for a function start address. |
| `get_function_disassembly_at(address)` | `{disassembly: list[str]}` | Linear-disassembly lines for the containing function. |
| `decompile_function_at(address)` | `{pseudocode: list[str]}` | Hex-Rays pseudocode lines for the containing function. |
| `get_function_callers(address)` | `{callers: list[{address: int, name: str, size: int, signature: str, flags: {noreturn: bool, library: bool, thunk: bool}, comment: str, repeatable_comment: str}]}` | Functions that call the containing function. |
| `get_function_callees(address)` | `{callees: list[{address: int, name: str, size: int, signature: str, flags: {noreturn: bool, library: bool, thunk: bool}, comment: str, repeatable_comment: str}]}` | Functions called by the containing function. |
| `get_basic_blocks_at(address)` | `{basic_blocks: list[{start: int, end: int, successors: list[int], predecessors: list[int]}]}` | Control-flow graph basic blocks for the containing function. |
| `get_xrefs_to_at(address)` | `{xrefs: list[{from_address: int, type: str, is_call: bool, is_jump: bool}]}` | Cross-references that target an address. |
| `get_xrefs_from_at(address)` | `{xrefs: list[{to_address: int, type: str, is_call: bool, is_jump: bool}]}` | Cross-references that originate at an address. |
| `get_strings()` | `{strings: list[{address: int, length: int, type: str, value: str}]}` | All strings recognized by IDA analysis. |
| `get_string_at(address)` | `{string: str}` | Null-terminated C string decoded at an address. |
| `get_segments()` | `{segments: list[{name: str, start: int, end: int, size: int, permissions: int, class: str, bitness: int}]}` | Memory-segment descriptors for the loaded database. |
| `get_names()` | `{names: list[{address: int, name: str}]}` | All named addresses known to IDA. |
| `get_name_at(address)` | `{name: str}` | Symbol name at an exact address. |
| `demangle_name(name)` | `{demangled_name: str}` | Demangled form of a mangled symbol string. |
| `get_imports()` | `{imports: list[{address: int, name: str, module: str, ordinal: int}]}` | Imported symbols referenced by the binary. |
| `get_entries()` | `{entries: list[{ordinal: int, address: int, name: str, forwarder: str | None}]}` | Entry points and exported entry records. |
| `get_bytes_at(address, size)` | `{bytes: list[int]}` | Raw byte values from a contiguous address range. |
| `find_bytes(pattern)` | `{addresses: list[int]}` | Addresses where an exact byte pattern occurs. |
| `get_disassembly_at(address)` | `{disassembly: str}` | Disassembly text for one instruction address. |
| `get_instruction_at(address)` | `{address: int, size: int, mnemonic: str, disassembly: str, is_call: bool}` | Structured instruction fields for one address. |
| `get_address_type(address)` | `{address_type: Literal['code', 'data', 'unknown', 'invalid']}` | Address classification as code, data, unknown, or invalid. |
| `get_comment_at(address)` | `{comment: str}` | Comment text attached to an exact address. |

<!--- (autogenerated file: do not edit) -->
